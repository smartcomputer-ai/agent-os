# Garbage Collection and Reachability

This document defines the AgentOS reachability contract for content-addressed storage (CAS), baseline snapshots, and future garbage collection (GC). It specifies what counts as a reference, how roots are established, and which invariants make deterministic restore and safe compaction possible.

GC semantics are protocol-level. Implementations may differ (decode-at-GC vs precomputed adjacency), but they MUST preserve the same reachability result.

## Purpose and Scope

This specification exists to lock down protocol semantics needed for:

- deterministic restore from snapshots and journal tails
- safe future mark/sweep deletion in local and hosted deployments
- shared-CAS operation across many worlds

P1 scope is groundwork only. It defines roots, edge semantics, and baseline safety. It does not require deletion in this phase.

See also:

- `spec/02-architecture.md` for runtime and storage components
- `spec/03-air.md` for effect/schema definitions and event semantics

## Mental Model

Treat CAS as a set of immutable objects addressed by `sha256:...`.

- A snapshot is a restore root: it names the top-level objects needed to reconstruct world state.
- GC keeps all objects reachable from retained roots.
- Objects not reachable from retained roots may be deleted, subject to retention and grace policy.

Reachability depends on one function:

- `refs_of(object)` returns the object hashes referenced by that object.

This spec defines how `refs_of` is derived without ambiguity.

## Object Classes

### Node (Walkable)

A node is a structured, schema-known canonical CBOR object. Nodes are traversable: GC may decode them and extract typed `hash` fields recursively.

Examples include manifests, typed receipts/events, indexes, and other schema-bound control/data structures.

### Blob (Opaque)

A blob is opaque byte content. Blobs are not traversable by parsing arbitrary bytes.

Examples include WASM binaries, workspace file bytes, compressed artifacts, and arbitrary payload blobs.

### BlobEdge Node

`sys/BlobEdge@1` is a node that records explicit adjacency for an opaque blob:

- `blob_ref: hash`
- `refs: list<hash>`

The persisted pointer is `edge_ref`, which is the hash of this node. `edge_ref` is a normal node hash, not a separate storage class.

## Reachability Contract

AgentOS defines exactly two legal sources of CAS edges:

1. Typed traversal from schema-known nodes.
2. Explicit edge lists in `sys/BlobEdge@1`.

Normative rules:

- GC MUST NOT scan arbitrary blob bytes for references.
- Opaque blobs are leaves unless accompanied by explicit refs via `BlobEdge`.
- Any feature that introduces CAS references MUST expose them as typed `hash` fields or through `blob.put refs`.
- Protocol surfaces that produce bare hashes without provenance/context are invalid for GC safety.

## `blob.put@1` and `BlobEdge` Semantics

P1 updates `blob.put@1` in place to support explicit refs on opaque bytes.

- `sys/BlobPutParams@1 = { bytes: bytes, blob_ref?: hash, refs?: list<hash> }`
- `sys/BlobPutReceipt@1 = { blob_ref: hash, edge_ref: hash, size: nat }`

Required behavior:

- Kernel computes `computed_ref = sha256(bytes)`.
- If `blob_ref` is provided and differs from `computed_ref`, request is rejected.
- If `blob_ref` is omitted, kernel normalizes params with `blob_ref = computed_ref` before journaling/dispatch.
- Kernel writes a `sys/BlobEdge@1` node with `refs = []` when omitted.
- Receipt always returns `edge_ref`.

Writers SHOULD persist `edge_ref` (not just `blob_ref`) when later reachability of child refs matters.

## Snapshot Root Contract

Snapshots MUST carry all roots required for deterministic restore and GC traversal. At minimum:

- `manifest_hash`
- reducer state roots
- keyed reducer `cell_index_root` roots
- workspace roots (directly or via reducer-owned state roots)
- additional `pinned_roots[]`

Root completeness is non-negotiable. If a required root is omitted, restore/GC correctness is undefined.

## Baseline Snapshot Semantics

AgentOS uses a single restore contract: the active baseline snapshot is the semantic restore root.
Snapshots are not "optimization-only" in this model.

Baseline record shape:

- `snapshot_ref: hash`
- `height: nat`
- `logical_time_ns: nat`
- `receipt_horizon_height?: nat`

World creation requirement:

- A world MUST have an active baseline at creation time.
- Unseeded world creation MUST write an initial baseline snapshot for empty/default runtime state.
- Seeded/forked world creation MUST set the active baseline to the selected seed/fork snapshot.

Restore from baseline:

- load `snapshot_ref`
- replay journal entries with `height >= baseline.height`

Safety fence:

- A baseline is valid only when receipt horizon preconditions hold.
- In v0.11 P1, implementations treat `receipt_horizon_height == height` as the promotable baseline shape.
- Replay-or-die remains mandatory: baseline+tail replay MUST produce byte-identical state to full replay.

## Traversal Semantics

### Root Selection

Retention policy selects roots per world, typically:

- active `manifest_hash`
- retained baseline roots (latest K baselines or policy-defined baseline set)
- explicit `pinned_roots[]`

For shared CAS, hosted GC should mark over the union of retained roots across all worlds before sweeping.

### Mark Phase

Logical algorithm:

1. Seed worklist from retained roots.
2. Pop object ref.
3. If object is a typed node, enqueue typed outgoing refs.
4. If object is `sys/BlobEdge@1`, enqueue `blob_ref` and each entry in `refs`.
5. If object is an opaque blob without edge metadata, mark as leaf.
6. Repeat until worklist is empty.

Traversal always relies on protocol context at each hop. A hash value alone does not encode whether bytes are node-vs-blob or how to decode; context from snapshot fields, schema-bound records, and edge-node shape provides interpretation.

### Sweep Phase

After mark, unmarked objects outside retention/grace windows are eligible for deletion.

Deletion mechanics are implementation-defined and are out of scope for P1.

## Responsibility Split

### System Responsibility

Kernel/protocol surfaces MUST ensure system-defined typed payloads expose refs in traversable form. This includes snapshot completeness, manifest linkage, reducer state roots, cell index roots, and workspace roots.

### Application Responsibility

Applications are responsible only when they store semantically referential data as opaque bytes.

- If hashes are embedded in opaque text/bytes/json blobs, GC cannot infer references.
- Applications MUST either remodel data as typed hash fields or attach refs via `blob.put refs`.

## Implementation Strategies (Same Semantics)

Two implementations are valid for typed-node traversal:

- Decode-at-GC: decode typed nodes during mark and extract hash fields.
- Extract-at-ingest: maintain an adjacency index/cache (`hash -> refs[]`) at write time.

The adjacency index is a derived cache, not a new source of truth. If missing or corrupt, implementations MUST be able to rebuild it from canonical CAS content.

## Reducers, Cells, and Workspaces

- Reducer state is traversable when schema-known and rooted from snapshots.
- Keyed reducers are rooted via `cell_index_root`; index nodes lead to per-cell state blobs/nodes.
- Workspace content is retained via workspace roots reachable from snapshot roots.

If reducer/workspace payloads hide hashes inside opaque bytes without explicit refs, those hidden references are out of contract and may be collected.

## P1 Deliverables and Non-Goals

P1 required outcomes:

- define `sys/BlobEdge@1`
- update `blob.put@1` schema/receipt semantics to include optional refs and returned `edge_ref`
- define baseline snapshot root semantics and receipt horizon fencing
- codify snapshot root completeness for future GC

P1 non-goals:

- no mark/sweep deletion requirement yet
- no journal segment deletion semantics yet
- no distributed lease/scheduler work
