# P2.3: Tool Loop Safety, Limits, and Context Bounds

**Stage**: P2.3  
**Status**: Proposed  
**Depends on**: P2.1, P2.2

## Purpose

Lock down runtime safety and context discipline for tool-using agent loops.

This stage resolves concerns #3 and #4.

## Scope

1. Canonical stop/limit semantics:
   - max turns,
   - max tool rounds per turn,
   - max steps per run,
   - max tool calls per step.
2. Loop detection contract:
   - deterministic signature model,
   - thresholds and reaction policy (`inject_steer`, `fail`, `complete_with_warning`).
3. Tool output bounding contract:
   - full-fidelity operator output retained in CAS,
   - bounded model-context output retained separately,
   - deterministic truncation marker with digest.
4. Context pressure signaling:
   - standardized threshold events (for example 70/85/95%).

## Non-Goals

- SSE transport/protocol details.
- Full failure taxonomy ownership rules (handled in P2.5).

## Deliverables

1. SDK types for limits, loop policy, truncation metadata.
2. Reducer helper logic for limit checks and loop detection.
3. Tool result envelope schema additions:
   - `operator_output_ref`
   - `model_output_ref`
   - `truncation_meta`
4. Deterministic truncation helper in `aos-agent-sdk`.

## Implementation Notes

- Replace app-local truncation constants (for example Demiurge reducer hardcoded limits) with SDK-level policy input.
- Preserve reducer/plan boundaries:
  - reducer decides loop/state transitions,
  - plan and adapters execute tool/LLM effects.

## Exit Criteria

1. Long tool output is deterministically truncated with stable marker/digest.
2. Full output remains available to operator channel via CAS.
3. Limit exceed paths produce canonical terminal reasons.
4. Loop detection triggers configured policy and avoids infinite ineffective cycles.
5. Replay test verifies identical terminal state and bounded payload refs.

