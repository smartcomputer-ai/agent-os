# P2.2 LLM Boundary Issue: `sys/*` vs `aos.agent/*`

**Date**: 2026-02-13  
**Status**: Accepted; roadmap rebaseline applied on 2026-02-13 (cleanup complete, mapper flow landed)

## Summary

There was a boundary conflict in early P2.2 direction:

- `sys/llm.generate@1` is a low-level built-in effect contract used by core runtime + host adapters.
- `aos.agent/*` is an SDK layer that should build on top of core primitives.

Early scaffold work blurred this boundary by defining `sys/Llm*` schemas inside `crates/aos-agent-sdk` AIR assets. That made SDK assets appear authoritative for core `sys/*` contracts.

The rebaseline keeps `sys/llm.generate@1` agent-agnostic, and keeps SDK contracts focused on session/run semantics and deterministic mapping.

## Context

### Architecture expectations

1. `sys/*` is core runtime surface:
   - built-in schemas/effects in `spec/defs/*`
   - shared low-level Rust types in core crates (`aos-effects`, `aos-host` adapters)
2. `aos.agent/*` is product/SDK layer:
   - session lifecycle, run config, loop state
   - compiles down to `sys/*` effects for execution

### What happened in scaffolding

In `crates/aos-agent-sdk/air/schemas.air.json`, temporary drafts introduced `sys/Llm*` schema definitions. That is now treated as invalid ownership and removed.

## Why this is a problem

1. Layer inversion: SDK should not define core built-in contracts.
2. Coupling risk: SDK iteration could accidentally fork runtime schemas.
3. Migration ambiguity: unclear source of truth for `sys/Llm*`.
4. Operational risk: adapter behavior can drift from manifests/tests.

## Recommendation

Use strict two-layer separation:

1. Keep `sys/llm.generate@1` fully agent-agnostic.
2. Keep agent semantics in `aos.agent/*` contracts.
3. Keep run config explicit (`provider`, `model`, optional tuning controls).
4. Use a deterministic translation boundary from run/step state to `sys/LlmGenerateParams@1`.
5. Evolve `sys/Llm*` only in core sources (`spec/defs`, `aos-effects`, `aos-host`).

## Recommended implementation model

### A. Contract ownership

1. Core owns:
   - `sys/llm.generate@1`
   - `sys/LlmGenerateParams@1`
   - `sys/LlmGenerateReceipt@1`
2. SDK owns:
   - session/run/turn/step contracts
   - mapper helpers and reducer-facing envelopes

### B. Execution flow

1. Session reducer snapshots immutable `active_run_config` at `RunStarted`.
2. Plan/reducer helper materializes `sys/LlmGenerateParams@1` from:
   - active run config (`provider`, `model`, optional `reasoning_effort`, optional `max_tokens`)
   - deterministic step context (`message_refs`, tools, metadata, stop sequences, response format/options refs)
3. Host executes `llm.generate` using core adapters.
4. Receipt (`sys/LlmGenerateReceipt@1`) is ingested and mapped to SDK events/state.

### C. Defaults and determinism

- Host/provider defaults are only applied when a field is explicitly left unset in params.
- Host catalog metadata may validate and produce diagnostics, but may not mutate journaled effect params.

## Immediate cleanup tasks

1. [x] Remove any SDK-local `sys/Llm*` schema ownership.
2. [x] Remove provider-profile and profile-lookup contracts from SDK scope.
3. [x] Keep SDK manifest focused on direct session/run contracts.
4. [x] Add/keep SDK-side mapper helpers:
   - `RunConfig + StepContext -> sys::LlmGenerateParams`
5. [x] If richer low-level fields are needed, evolve them in core:
   - `spec/defs/builtin-schemas.air.json`
   - `aos-effects` `LlmGenerateParams/Receipt`
   - `aos-host` adapter mapping into `aos-llm::Request`

## Decision statement for roadmap docs

P2.2 is interpreted as:

- "Evolve low-level LLM contract in core (`sys/*`)"
- and "use direct provider/model run config in SDK (`aos.agent/*`)"

not as profile-registry choreography and not as SDK-local ownership of core `sys/*` schemas.

## Resume checklist

1. [x] Clean SDK AIR assets to remove profile/catalog schemas and reducer routing.
2. [x] Implement core-side `sys/Llm*` evolution in `spec/defs` + runtime crates.
3. [x] Implement SDK mapper flow on top.
4. [ ] Add integration tests proving:
   - core adapter remains agent-agnostic,
   - SDK deterministically maps run/step state into core params,
   - replay determinism is preserved.

Status note (2026-02-13): SDK mapper helpers and a smoke replay slice are in place. A consolidated integration assertion set for all three bullets above remains open.
