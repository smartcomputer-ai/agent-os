# P3.3: Plan Reuse (Composition + Upstream Sync)

**Priority**: P3  
**Effort**: Medium-High  
**Risk if deferred**: Medium (continued plan duplication across worlds/apps)  
**Status**: Proposed

## Goal

Reduce duplicated AIR plan logic across SDK consumers by combining:

1. **Runtime plan composition** (`spawn_plan`, `await_plan`, `spawn_for_each`, `await_plans_all`) based on `roadmap/vX-future/p3-plans-v1.1.md`.
2. **Build-time plan reuse** from upstream folders/crates using the existing `aos.sync.json` import model (same mechanism as P3.1 defs sync).

This gives a near-term reuse path (imports) and a long-term composability path (sub-plans).

## Problem

Today, consumers often duplicate full plan bodies when they only need different input/output envelopes or trigger wiring (example: workspace sync wrapper plans).

Main causes:

1. Plan input/output contracts differ per app event envelope.
2. AIR v1.0 has no in-plan subplan call primitive.
3. Teams can import defs, but do not yet have a standard for reusable plan packs and world-level plan composition conventions.

## Scope

### In scope

1. Define plan composition semantics and contract surface for future implementation (v1.1+).
2. Define a v0.10-compatible plan sync/import strategy from upstream directories/crates.
3. Specify SDK export layout and app consumption conventions.

### Out of scope

1. Full kernel implementation of new plan ops in this P3.3 doc.
2. Macro/template language in AIR itself.
3. Runtime dynamic plan loading from workspace content.

## Part A: Runtime Plan Composition (from v1.1 design)

Adopt the composition model from `roadmap/vX-future/p3-plans-v1.1.md`:

1. `spawn_plan`: start child plan instance with typed input.
2. `await_plan`: await child completion and bind typed result variant (`Ok | Error | Canceled`).
3. `spawn_for_each`: fan-out child plans over input list.
4. `await_plans_all`: barrier join over child handles.
5. `sys/PlanHandle@1`: opaque typed handle for child instances.

### Why this helps reuse

It allows one shared "core" plan to be reused by many thin wrappers:

1. Wrapper plan normalizes app-specific input envelope.
2. Wrapper plan calls shared core plan via `spawn_plan`.
3. Wrapper plan maps core output into app-specific event envelope.

Result: duplicate effect orchestration stays in one place.

### Determinism and governance constraints

1. Child plan instances inherit pinned manifest hash from parent.
2. Parent-child linkage is journaled (`parent_instance_id`).
3. New ops remain control-plane only; external nondeterminism still only through receipts.
4. Existing caps/policy enforcement remains unchanged for emitted effects.

### Validation rules (planned)

1. `await_plan.for` must reference a prior `spawn_plan` handle.
2. `spawn_for_each.inputs` must type-check as list of child input type.
3. `await_plans_all.handles` must be homogeneous in v1.1.
4. New invariant timing semantics follow the v1.1 proposal.

## Part B: Upstream Plan Sync via `aos.sync.json` Imports (v0.10-capable)

Reuse the same import mechanics delivered in P3.1 (`air.imports`) for plans.

### Key point

No new import transport is needed. `manifest_loader` already merges `defplan` from import roots with hash-based conflict checks.

### Proposed usage model

1. SDK publishes defs-only exports containing reusable plans.
2. App world imports SDK export via `aos.sync.json` (`path` or `cargo` import).
3. App manifest references imported plans by name in:
   - `plans`
   - `triggers`
4. App keeps local ownership of:
   - `defaults.cap_grants`
   - `policies`
   - routing and event schemas specific to its reducer contracts

### `aos.sync.json` example (cargo import)

```json
{
  "air": {
    "dir": "air",
    "imports": [
      {
        "cargo": {
          "package": "aos-agent-sdk",
          "air_dir": "air/exports/plan-packs/session-core",
          "manifest_path": "../../Cargo.toml"
        }
      }
    ]
  }
}
```

### Merge/conflict behavior

Use P3.1 semantics unchanged:

1. Duplicate plan name + identical hash: allowed (dedup).
2. Duplicate plan name + different hash: hard error.
3. Import roots may not include manifest nodes.

## Reusable Plan Pack Convention (SDK exports)

Define a stable export convention in `crates/aos-agent-sdk`:

1. `air/exports/plan-packs/<pack>/defs.air.json`
2. `air/exports/plan-packs/<pack>/README.md`

`defs.air.json` can include:

1. `defplan` nodes (core reusable plans)
2. required supporting `defschema` nodes for plan IO/results
3. optional helper `defeffect` references if needed for validation completeness

No manifest in exports.

## Design Guidance for Shared Plans

To maximize reuse without new kernel ops yet:

1. Keep shared plan inputs narrow and envelope-neutral (domain records, not app event wrappers).
2. Keep shared plan outputs typed and minimal.
3. Keep wrapper plans thin:
   - extract/normalize input,
   - call shared logic (future: `spawn_plan`; present: copy-minimized wrapper),
   - re-envelope output event.
4. Keep cap slot names stable and documented in pack README.

## Migration Strategy

### Phase 1 (now, v0.10)

1. Create SDK plan-pack exports.
2. Import plan packs in smoke fixtures/apps via `air.imports`.
3. Replace local duplicated plan files where contracts already match.
4. Where contracts differ, keep minimal wrapper plans only.

### Phase 2 (future, v1.1+)

1. Implement `spawn_plan`/`await_plan` and related ops.
2. Refactor wrappers to call shared core plans instead of duplicating step logic.
3. Optionally add lint guidance: "prefer imported core plan + wrapper over copied full plan."

## Example: Workspace Sync Reuse Path

1. Export SDK core workspace sync plan in plan pack.
2. App imports plan pack.
3. If reducer consumes direct workspace events, app can trigger imported plan directly.
4. If reducer consumes `SessionEvent` envelope, app keeps a tiny wrapper that only:
   - extracts `WorkspaceSyncRequested`,
   - delegates to core sync flow (future via `spawn_plan`; interim via small bridge pattern).

## Testing / Validation

1. Loader tests:
   - imported `defplan` merged correctly,
   - conflicting imported plan definitions fail deterministically.
2. CLI dry-run:
   - `aos push --dry-run` resolves imported plan packs.
3. Smoke fixtures:
   - at least one fixture uses imported plan pack (no local duplicate full plan).
4. Replay parity:
   - imported-plan worlds preserve replay determinism.

## Risks / Open Questions

1. **Name/version discipline**: shared plans must version cleanly (`@1`, `@2`) to avoid conflicts.
2. **Cap slot drift**: imported plan slot names are contract surface; docs must be explicit.
3. **Template vs composition**: imports solve distribution, not parameterized instantiation.
4. **Wrapper debt**: without v1.1 ops, some wrappers remain unavoidable.

## Definition of Done

1. SDK defines at least one plan-pack export with reusable `defplan` nodes.
2. At least one consumer world imports and uses an SDK plan from upstream crate path.
3. Documentation clearly separates:
   - v0.10 import-based reuse,
   - v1.1 runtime composition reuse (`spawn/await`).
4. Follow-up implementation issue(s) are created for kernel/validator work for composition ops.
