# P2.2: Provider Profiles and LLM Contract Evolution

**Stage**: P2.2  
**Status**: Proposed  
**Depends on**: P2.1

## Purpose

Standardize provider strategy and align effect contracts with required agent runtime controls.

This stage resolves concerns #2 and #7.

## Scope

1. Define provider profile contract:
   - `aos.agent/ProviderProfile@1`
   - capability flags (`supports_parallel_tool_calls`, `supports_reasoning_effort`, `supports_streaming`, `supports_tool_choice_named`)
   - profile defaults (`provider_options_default`, `context_window_hint`, model defaults)
2. Evolve LLM effect schemas:
   - introduce `sys/LlmGenerateParams@2`
   - introduce `sys/LlmGenerateReceipt@2`
3. Thread profile/runtime controls through host adapter:
   - `reasoning_effort`
   - `provider_options`
   - `response_format`
   - optional stop and metadata fields
4. Keep normalized + raw output model:
   - `output_ref` for reducer-facing normalized envelope
   - `raw_output_ref` for provider-native audit/debug

## Non-Goals

- Loop detection and context truncation policy.
- Event stream API guarantees.

## Deliverables

1. Profile schemas and resolver helpers in `aos-agent-sdk`.
2. Updated built-in schema set for LLM params/receipt v2.
3. `aos-host` LLM adapter updates to consume/pass new fields.
4. Compatibility shim strategy for v1 worlds during migration.

## Implementation Notes

- `crates/aos-llm` already supports provider options and reasoning fields; this stage formalizes the contract between AIR effect params and adapter request wiring.
- Keep provider-specific semantics in profile/adapter layer; keep reducer-facing envelopes provider-agnostic.

## Exit Criteria

1. OpenAI and Anthropic profiles pass the same core contract tests for no-tool and tool-call flows.
2. Provider profile flags drive behavior without app-level branching on provider name.
3. `provider_options` round-trip verified from effect params to provider request (integration test).
4. `output_ref` normalized payload and `raw_output_ref` provider payload are both populated where available.
5. Replay parity preserved (no nondeterministic fields leak into reducer decisions).

