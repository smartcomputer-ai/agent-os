# P2.1: Session Contracts and Core `aos.agent/*` Schemas

**Stage**: P2.1  
**Status**: In Progress (core lifecycle + settle/stale semantics landed)  
**Depends on**: P1 complete

## Implementation Progress (2026-02-13)

Completed:

1. Added new SDK crate and workspace wiring:
   - `crates/aos-agent-sdk`
   - root `Cargo.toml` member entry
2. Added P2.1 contract schema assets:
   - `crates/aos-agent-sdk/air/schemas.air.json`
   - includes all listed P2.1 `aos.agent/*` core schemas.
3. Added SDK module and manifest assets:
   - `crates/aos-agent-sdk/air/module.air.json`
   - `crates/aos-agent-sdk/air/manifest.air.json`
4. Added Rust contract types and helper scaffolding:
   - `crates/aos-agent-sdk/src/contracts/*`
   - `crates/aos-agent-sdk/src/helpers/*`
5. Added isolated WASM module bins (pattern aligned to `crates/aos-sys`):
   - `crates/aos-agent-sdk/src/bin/session_reducer.rs`
   - `crates/aos-agent-sdk/src/bin/session_event_echo.rs`
6. Build status:
   - `cargo check -p aos-agent-sdk` passes.
7. Implemented first functional reducer slice:
   - shared deterministic event application helper (`apply_session_event`),
   - run-start config selection/snapshot and required field validation,
   - pause/resume/cancel command application with epoch-fence increment on cancel.
8. Added deterministic P2.1 coverage:
   - SDK unit tests for run-start snapshot + validation failure cases,
   - smoke fixture `10-agent-session` with replay-parity verification.
9. Implemented lifecycle/control concurrency semantics:
   - step-boundary handling for `steer` and `follow_up`,
   - active tool-batch start/settle gating with deterministic call-id ordering,
   - stale receipt marking (`IgnoredStale`) across epoch fences,
   - lease-expiry cancellation path with deterministic finalize-to-`Cancelled`.
10. Expanded smoke coverage in `10-agent-session`:
   - tool batch settle flow,
   - cancel with stale late receipts,
   - lease-expiry cancellation path,
   - replay parity after multi-run lifecycle progression.

Remaining for full P2.1 completion:

1. Add explicit dedicated smoke assertion for lease heartbeat renewal (not just expiry).
2. Add one high-contention multi-batch/multi-receipt scenario to harden fan-in behavior under heavier ordering permutations.

## Purpose

Establish the base session lifecycle and host-control contract so every agent app shares the same run semantics.

This stage resolves the primary gap from concern #1 (host-control underspecified) and lays schema foundations used by all later stages.

This document is the normative source of truth for P2.1 session contracts. Later stages may extend behavior but must not redefine these base contracts.

## Why Multiple IDs

We need four identity levels because they solve different problems:

- `session_id`: stable identity for long-lived conversation/state.
- `run_id`: identity for one execution attempt inside a session.
- `turn_id`: identity for one LLM round within a run.
- `step_id`: identity for one fine-grained action boundary inside a turn.

If we collapse these into one ID, we lose deterministic cancellation fences, traceability, and clean operator controls.

## Identity Model (hierarchical)

Instead of opaque unrelated strings, IDs are hierarchical so parent/child relationships are explicit:

- `RunId = { session_id, run_seq }`
- `TurnId = { run_id, turn_seq }`
- `StepId = { turn_id, step_seq }`

This allows deterministic incrementing in reducer state while limiting UUID generation to the session boundary.

## Scope

1. Define core SDK schemas under `aos.agent/*`:
   - `aos.agent/SessionId@1`
   - `aos.agent/RunId@1`
   - `aos.agent/TurnId@1`
   - `aos.agent/StepId@1`
   - `aos.agent/ToolBatchId@1`
   - `aos.agent/ToolCallStatus@1`
   - `aos.agent/ActiveToolBatch@1`
   - `aos.agent/RunLease@1`
   - `aos.agent/ReasoningEffort@1`
   - `aos.agent/SessionConfig@1`
   - `aos.agent/RunConfig@1`
   - `aos.agent/SessionLifecycle@1`
   - `aos.agent/HostCommand@1`
   - `aos.agent/SessionEventKind@1`
   - `aos.agent/SessionState@1`
   - `aos.agent/SessionEvent@1`
2. Define lifecycle states and transitions:
   - `Idle`, `Running`, `WaitingInput`, `Paused`, `Cancelling`, `Completed`, `Failed`, `Cancelled`
3. Define control observation semantics:
   - `steer`, `follow_up`, `pause`, `resume`, `cancel`, `lease_heartbeat`
4. Define determinism fences to ignore stale completions:
   - `session_epoch`
   - `step_epoch`
   - lease fence (`RunLease@1` + heartbeat checks)
5. Define parallel fan-out/fan-in settle semantics:
   - one active tool batch per tool round,
   - no next LLM step until batch settled.
6. Add crate scaffolding:
   - `crates/aos-agent-sdk` with shared types and reducer helper traits.
   - keep SDK reducer/pure WASM modules in this crate (`src/bin/*`) for v0.10.
   - keep reusable SDK AIR assets under `crates/aos-agent-sdk/air/`.
7. Define the P2.1 execution harness boundary:
   - use `crates/aos-smoke` fixtures for end-to-end lifecycle/concurrency validation.
   - do not create a separate e2e runner in `aos-agent-sdk`.

## Proposed Schema Shapes (AIR-style)

### Identity Schemas

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionId@1",
  "type": { "uuid": {} }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunId@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "run_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/TurnId@1",
  "type": {
    "record": {
      "run_id": { "ref": "aos.agent/RunId@1" },
      "turn_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/StepId@1",
  "type": {
    "record": {
      "turn_id": { "ref": "aos.agent/TurnId@1" },
      "step_seq": { "nat": {} }
    }
  }
}
```

### Lifecycle + Config Schemas

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ReasoningEffort@1",
  "type": {
    "variant": {
      "Low": { "unit": {} },
      "Medium": { "unit": {} },
      "High": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionConfig@1",
  "type": {
    "record": {
      "provider": { "text": {} },
      "model": { "text": {} },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

`SessionConfig@1` is mutable default config for future runs.
`RunConfig@1` is the immutable snapshot for one active run.

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunConfig@1",
  "type": {
    "record": {
      "provider": { "text": {} },
      "model": { "text": {} },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionLifecycle@1",
  "type": {
    "variant": {
      "Idle": { "unit": {} },
      "Running": { "unit": {} },
      "WaitingInput": { "unit": {} },
      "Paused": { "unit": {} },
      "Cancelling": { "unit": {} },
      "Completed": { "unit": {} },
      "Failed": { "unit": {} },
      "Cancelled": { "unit": {} }
    }
  }
}
```

### Host Command Schema

```json
{
  "$kind": "defschema",
  "name": "aos.agent/HostCommand@1",
  "type": {
    "record": {
      "command_id": { "uuid": {} },
      "target_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "expected_session_epoch": { "option": { "nat": {} } },
      "issued_at": { "time": {} },
      "command": {
        "variant": {
          "Steer": { "record": { "text": { "text": {} } } },
          "FollowUp": { "record": { "text": { "text": {} } } },
          "Pause": { "unit": {} },
          "Resume": { "unit": {} },
          "Cancel": { "record": { "reason": { "option": { "text": {} } } } },
          "LeaseHeartbeat": {
            "record": {
              "lease_id": { "uuid": {} },
              "heartbeat_at": { "time": {} }
            }
          }
        }
      }
    }
  }
}
```

### Session State + Events

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionState@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "lifecycle": { "ref": "aos.agent/SessionLifecycle@1" },
      "session_epoch": { "nat": {} },
      "step_epoch": { "nat": {} },
      "next_run_seq": { "nat": {} },
      "next_turn_seq": { "nat": {} },
      "next_step_seq": { "nat": {} },
      "session_config": { "ref": "aos.agent/SessionConfig@1" },
      "active_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "active_run_config": { "option": { "ref": "aos.agent/RunConfig@1" } },
      "active_turn_id": { "option": { "ref": "aos.agent/TurnId@1" } },
      "active_step_id": { "option": { "ref": "aos.agent/StepId@1" } },
      "active_tool_batch": { "option": { "ref": "aos.agent/ActiveToolBatch@1" } },
      "in_flight_effects": { "nat": {} },
      "max_in_flight_effects": { "nat": {} },
      "active_run_lease": { "option": { "ref": "aos.agent/RunLease@1" } },
      "last_heartbeat_at": { "option": { "time": {} } },
      "pending_steer": { "list": { "text": {} } },
      "pending_follow_up": { "list": { "text": {} } },
      "created_at": { "time": {} },
      "updated_at": { "time": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionEventKind@1",
  "type": {
    "variant": {
      "RunRequested": {
        "record": {
          "input_ref": { "hash": {} },
          "run_overrides": { "option": { "ref": "aos.agent/SessionConfig@1" } }
        }
      },
      "RunStarted": { "unit": {} },
      "HostCommandReceived": { "ref": "aos.agent/HostCommand@1" },
      "HostCommandApplied": { "record": { "command_id": { "uuid": {} } } },
      "LifecycleChanged": { "ref": "aos.agent/SessionLifecycle@1" },
      "RunCompleted": { "unit": {} },
      "RunFailed": { "record": { "code": { "text": {} }, "detail": { "text": {} } } },
      "RunCancelled": { "record": { "reason": { "option": { "text": {} } } } }
    }
  }
}
```

## Model Mutability Rule

Provider/model can change within a session, but only at run boundaries:

1. Session stores mutable defaults in `session_config`.
2. `RunRequested.run_overrides` may fully replace those defaults for the next run.
3. On `RunStarted`, reducer snapshots immutable `active_run_config`.
4. `active_run_config.provider` and `active_run_config.model` are immutable until run terminal state.
5. Next run may use a different provider/model.

## Deterministic Parallel Tool Batch Contract

Rules:

1. A batch is settled only when every `expected_call_id` is in terminal `{Succeeded, Failed, IgnoredStale, Cancelled}`.
2. Receipt ingestion order must not affect semantic `results_ref` ordering. Results are normalized by call id order.
3. Reducer may advance to next LLM step only after batch settled.

## Pause / Resume / Cancel Semantics

1. `Pause` transitions `Running -> Paused` only at a step boundary.
2. While `Paused`, no new effect intents are emitted.
3. In-flight receipts during `Paused` are accepted and journaled, and only mutate active batch status.
4. `Resume` transitions `Paused -> Running` and continues from reducer state without replaying settled call ids.
5. `Cancel` transitions `Running|Paused -> Cancelling`, increments both `session_epoch` and `step_epoch`, and blocks new effect intents.
6. After `Cancelling`, terminal transition to `Cancelled` occurs when all in-flight call ids are terminal or ignored stale.
7. Any receipt tagged with stale `(run_id, session_epoch, step_epoch)` is recorded for audit and marked `IgnoredStale`.

## Non-Goals

- Provider catalog/profile indirection.
- Tool output truncation/bounding policy (handled in P2.3).
- Failure taxonomy ownership and retry strategy (handled in P2.5).
- Streaming/event transport details.

## Deliverables

1. New AIR schema files for session lifecycle/control contracts.
2. `aos-agent-sdk` crate with core IDs and state/event types, lifecycle helpers, queue semantics, and settle helpers.
3. Template keyed reducer and routing conventions:
   - key by `session_id`,
   - route `SessionEvent` to `SessionReducer`.
4. Cross-stage contract notes for P2.2/P2.3/P2.5 so later stages extend but do not redefine base session semantics.
5. P2.1 smoke fixture(s) under `crates/aos-smoke` covering lifecycle/control behavior with deterministic replay assertions.

## Exit Criteria

1. Deterministic no-tool run works end-to-end with lifecycle transitions.
2. `steer` is observed at step boundary before next LLM step.
3. `follow_up` is queued and consumed only after current run reaches `Idle`/`WaitingInput`.
4. Parallel tool fan-out/fan-in blocks next LLM step until active batch settles deterministically.
5. `cancel` transitions to `Cancelling` and ultimately `Cancelled`; stale late results are recorded and marked `IgnoredStale`.
6. Lease heartbeat renewal and lease-expiry cancellation path are deterministic from journaled command payloads.
7. Replay test proves byte-identical final state for equivalent journal.
8. P2.1 end-to-end coverage executes via `aos-smoke` fixtures (no separate SDK-local e2e runner).

Status note (2026-02-13): implementation now satisfies #1, #2, #3, #4, #5, #7, #8 and the lease-expiry portion of #6. A dedicated heartbeat-renewal coverage assertion remains open.
