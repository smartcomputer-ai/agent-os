# P2.1: Session Contracts and Core `aos.agent/*` Schemas

**Stage**: P2.1  
**Status**: Proposed  
**Depends on**: P1 complete

## Purpose

Establish the base session lifecycle and host-control contract so every agent app shares the same run semantics.

This stage resolves the primary gap from concern #1 (host-control underspecified) and lays schema foundations used by all later stages.

This document is the normative source of truth for P2.1 session contracts. Later stages may extend behavior but must not redefine these base contracts.

## Why Multiple IDs

We need four identity levels because they solve different problems:

- `session_id`: stable identity for long-lived conversation/state.
- `run_id`: identity for one execution attempt inside a session.
- `turn_id`: identity for one LLM round within a run.
- `step_id`: identity for one fine-grained action boundary inside a turn.

If we collapse these into one ID, we lose deterministic cancellation fences, traceability, and clean operator controls.

### Function of each ID

1. `session_id`
   - Reducer cell key (`key_field` target).
   - Long-lived memory boundary (settings/history/cache).
   - Used by UI/API as the durable handle.
2. `run_id`
   - Distinguishes separate executions in the same session.
   - Terminal state boundary (`Completed`/`Failed`/`Cancelled`) is per run.
   - Needed so late receipts from old runs can be ignored.
3. `turn_id`
   - Groups one LLM request/response cycle.
   - Correlates tool calls/results to the exact model response that produced them.
4. `step_id`
   - Total ordering inside a turn for host-control observation and event replay analysis.
   - Causation anchor for effect intents/receipts and diagnostics.

## Identity Model (hierarchical)

Instead of opaque unrelated strings, IDs are hierarchical so parent/child relationships are explicit:

- `RunId = { session_id, run_seq }`
- `TurnId = { run_id, turn_seq }`
- `StepId = { turn_id, step_seq }`

This allows deterministic incrementing in reducer state while limiting UUID generation to the session boundary.

## Scope

1. Define core SDK schemas under `aos.agent/*`:
   - `aos.agent/SessionId@1`
   - `aos.agent/ProviderProfileId@1`
   - `aos.agent/RunId@1`
   - `aos.agent/TurnId@1`
   - `aos.agent/StepId@1`
   - `aos.agent/ToolBatchId@1`
   - `aos.agent/ToolCallStatus@1`
   - `aos.agent/ActiveToolBatch@1`
   - `aos.agent/RunLease@1`
   - `aos.agent/ReasoningEffort@1`
   - `aos.agent/SessionConfig@1`
   - `aos.agent/RunConfig@1`
   - `aos.agent/SessionLifecycle@1`
   - `aos.agent/HostCommand@1`
   - `aos.agent/SessionEventKind@1`
   - `aos.agent/SessionState@1`
   - `aos.agent/SessionEvent@1`
2. Define lifecycle states and transitions:
   - `Idle`, `Running`, `WaitingInput`, `Paused`, `Cancelling`, `Completed`, `Failed`, `Cancelled`
3. Define control observation semantics:
   - `steer`, `follow_up`, `pause`, `resume`, `cancel`, `lease_heartbeat`
4. Define determinism fences to ignore stale completions:
   - `session_epoch`
   - `step_epoch`
   - lease fence (`RunLease@1` + heartbeat checks)
5. Define parallel fan-out/fan-in settle semantics:
   - one active tool batch per tool round,
   - no next LLM step until batch settled.
6. Add crate scaffolding:
   - `crates/aos-agent-sdk` with shared types and reducer helper traits.

## Proposed Schema Shapes (AIR-style)

Below is the intended shape. Final field names can be adjusted, but the semantics should stay.

### Identity Schemas

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionId@1",
  "type": { "uuid": {} }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ProviderProfileId@1",
  "type": { "text": {} }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunId@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "run_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/TurnId@1",
  "type": {
    "record": {
      "run_id": { "ref": "aos.agent/RunId@1" },
      "turn_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/StepId@1",
  "type": {
    "record": {
      "turn_id": { "ref": "aos.agent/TurnId@1" },
      "step_seq": { "nat": {} }
    }
  }
}
```

### Lifecycle and Commands

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ReasoningEffort@1",
  "type": {
    "variant": {
      "Low": { "unit": {} },
      "Medium": { "unit": {} },
      "High": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionConfig@1",
  "type": {
    "record": {
      "provider_profile_id": {
        "option": { "ref": "aos.agent/ProviderProfileId@1" }
      },
      "provider": { "option": { "text": {} } },
      "model": { "option": { "text": {} } },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

`SessionConfig@1` and `RunConfig@1` intentionally share the same field shape.
They remain separate schema names because they have different lifecycle meaning:
- `SessionConfig@1`: mutable defaults for future runs.
- `RunConfig@1`: resolved immutable snapshot for one active run.

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunConfig@1",
  "type": {
    "record": {
      "provider_profile_id": {
        "option": { "ref": "aos.agent/ProviderProfileId@1" }
      },
      "provider": { "text": {} },
      "model": { "text": {} },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionLifecycle@1",
  "type": {
    "variant": {
      "Idle": { "unit": {} },
      "Running": { "unit": {} },
      "WaitingInput": { "unit": {} },
      "Paused": { "unit": {} },
      "Cancelling": { "unit": {} },
      "Completed": { "unit": {} },
      "Failed": { "unit": {} },
      "Cancelled": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/HostCommand@1",
  "type": {
    "record": {
      "command_id": { "uuid": {} },
      "target_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "expected_session_epoch": { "option": { "nat": {} } },
      "issued_at": { "time": {} },
      "command": {
        "variant": {
          "Steer": { "record": { "text": { "text": {} } } },
          "FollowUp": { "record": { "text": { "text": {} } } },
          "Pause": { "unit": {} },
          "Resume": { "unit": {} },
          "Cancel": { "record": { "reason": { "option": { "text": {} } } } },
          "LeaseHeartbeat": {
            "record": {
              "lease_id": { "uuid": {} },
              "heartbeat_at": { "time": {} }
            }
          }
        }
      }
    }
  }
}
```

`command_id` exists for idempotency and audit (host retries should not double-apply control).
`target_run_id` scopes the command to a specific run when provided.
`expected_session_epoch` is an optional optimistic-concurrency fence to reject stale control actions.

### Host command targeting semantics

- If `target_run_id` is present: apply only if it matches the active run, otherwise reject as stale/invalid target.
- If `target_run_id` is absent: apply to current active run (best-effort convenience path).
- If `expected_session_epoch` is present: apply only when it matches current session epoch.
- `LeaseHeartbeat` must target the active run lease and match `active_run_lease.lease_id`; non-matching lease ids are rejected and logged.

### Parallel tool batch and lease schemas

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ToolBatchId@1",
  "type": {
    "record": {
      "step_id": { "ref": "aos.agent/StepId@1" },
      "batch_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ToolCallStatus@1",
  "type": {
    "variant": {
      "Pending": { "unit": {} },
      "Succeeded": { "unit": {} },
      "Failed": { "record": { "code": { "text": {} }, "detail": { "text": {} } } },
      "IgnoredStale": { "unit": {} },
      "Cancelled": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ActiveToolBatch@1",
  "type": {
    "record": {
      "tool_batch_id": { "ref": "aos.agent/ToolBatchId@1" },
      "issued_at_step_epoch": { "nat": {} },
      "expected_call_ids": { "set": { "text": {} } },
      "call_status": {
        "map": {
          "key": { "text": {} },
          "value": { "ref": "aos.agent/ToolCallStatus@1" }
        }
      },
      "results_ref": { "option": { "hash": {} } }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunLease@1",
  "type": {
    "record": {
      "lease_id": { "uuid": {} },
      "issued_at": { "time": {} },
      "expires_at": { "time": {} },
      "heartbeat_timeout_secs": { "nat": {} }
    }
  }
}
```

### Session State

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionState@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "lifecycle": { "ref": "aos.agent/SessionLifecycle@1" },
      "session_epoch": { "nat": {} },
      "step_epoch": { "nat": {} },
      "next_run_seq": { "nat": {} },
      "next_turn_seq": { "nat": {} },
      "next_step_seq": { "nat": {} },
      "session_config": { "ref": "aos.agent/SessionConfig@1" },
      "active_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "active_run_config": { "option": { "ref": "aos.agent/RunConfig@1" } },
      "active_turn_id": { "option": { "ref": "aos.agent/TurnId@1" } },
      "active_step_id": { "option": { "ref": "aos.agent/StepId@1" } },
      "active_tool_batch": { "option": { "ref": "aos.agent/ActiveToolBatch@1" } },
      "in_flight_effects": { "nat": {} },
      "max_in_flight_effects": { "nat": {} },
      "active_run_lease": { "option": { "ref": "aos.agent/RunLease@1" } },
      "last_heartbeat_at": { "option": { "time": {} } },
      "pending_steer": { "list": { "text": {} } },
      "pending_follow_up": { "list": { "text": {} } },
      "created_at": { "time": {} },
      "updated_at": { "time": {} }
    }
  }
}
```

### Event Envelope

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionEvent@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "turn_id": { "option": { "ref": "aos.agent/TurnId@1" } },
      "step_id": { "option": { "ref": "aos.agent/StepId@1" } },
      "session_epoch": { "nat": {} },
      "step_epoch": { "nat": {} },
      "event": { "ref": "aos.agent/SessionEventKind@1" }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionEventKind@1",
  "type": {
    "variant": {
      "RunRequested": {
        "record": {
          "input_ref": { "hash": {} },
          "run_overrides": { "option": { "ref": "aos.agent/SessionConfig@1" } }
        }
      },
      "RunStarted": { "unit": {} },
      "HostCommandReceived": { "ref": "aos.agent/HostCommand@1" },
      "HostCommandApplied": { "record": { "command_id": { "uuid": {} } } },
      "LifecycleChanged": { "ref": "aos.agent/SessionLifecycle@1" },
      "RunCompleted": { "unit": {} },
      "RunFailed": { "record": { "code": { "text": {} }, "detail": { "text": {} } } },
      "RunCancelled": { "record": { "reason": { "option": { "text": {} } } } }
    }
  }
}
```

`SessionEvent` is an envelope so correlation fields are always present and uniform for tooling.

## Model Mutability Rule

Model/provider can change within a session, but only at run boundaries:

1. Session stores mutable defaults in `session_config`.
2. `RunRequested.run_overrides` may override those defaults for the next run.
3. On `RunStarted`, reducer resolves and snapshots `active_run_config`.
4. `active_run_config.provider` and `active_run_config.model` are immutable until run terminal state.
5. Next run may use different resolved model/provider.

## Deterministic Parallel Tool Batch Contract

Agents may issue multiple tool calls in one step. The reducer must track one active
batch per tool round and must not request the next LLM step until the batch is
settled.

Rules:

1. A batch is settled only when every `expected_call_id` is in terminal `{Succeeded, Failed, IgnoredStale, Cancelled}`.
2. Receipt ingestion order must not affect semantic `results_ref` ordering. Results are normalized by call id order.
3. Reducer may advance to next LLM step only after batch settled.

## Pause / Resume / Cancel Semantics with In-Flight Effects

These rules are mandatory:

1. `Pause` transitions `Running -> Paused` only at a step boundary.
2. While `Paused`, no new effect intents are emitted.
3. In-flight receipts during `Paused` are accepted and journaled, and only mutate active batch status.
4. `Resume` transitions `Paused -> Running` and continues from reducer state without replaying already-settled call ids.
5. `Cancel` transitions `Running|Paused -> Cancelling`, increments both `session_epoch` and `step_epoch`, and blocks new effect intents.
6. After `Cancelling`, terminal transition to `Cancelled` occurs when all in-flight call ids are terminal or ignored stale.
7. Any receipt tagged with stale `(run_id, session_epoch, step_epoch)` is recorded for audit and marked `IgnoredStale`.

## Long-Run Liveness and Lease Fence

Long-running autonomous runs must use lease fencing:

1. Host must renew lease before `expires_at` via `HostCommand.LeaseHeartbeat`.
2. If lease expires, reducer transitions to `Cancelling` with reason `lease_expired`.
3. Lease checks are deterministic: compare journaled `heartbeat_at` from command payload, never wall clock.

## Runtime Use of IDs (example timeline)

Given `session_id = "550e8400-e29b-41d4-a716-446655440000"`:

1. First input starts `run_id = {session_id:"550e8400-e29b-41d4-a716-446655440000", run_seq:1}`.
2. First model round starts `turn_id = {run_id, turn_seq:1}`.
3. Steps progress:
   - `step_id(..., step_seq:1)` for `LlmStepRequested`
   - `step_id(..., step_seq:2)` for tool fan-out request
   - `step_id(..., step_seq:3)` for result ingestion
4. Host issues cancel:
   - reducer sets lifecycle `Cancelling`
   - increments `session_epoch` and `step_epoch`
5. Late receipt from old step arrives with stale fence values:
   - recorded and marked `IgnoredStale`.

This is why IDs and epochs are both needed:
- IDs give lineage,
- epochs give safe invalidation boundaries.

## Relationship to `tmp-llm-lib-code/02-coding-agent-loop-spec.md`

That document is useful inspiration, but it is not a source of truth for AOS contracts.

### Adopt (with adaptation)

1. Explicit session lifecycle states.
2. Host control queues (`steer`, `follow_up`) and next-boundary observation semantics.
3. Limit-driven loop control (`max_turns`, round limits) as first-class config.
4. Strong event-driven mindset for host integrations.

### Do not adopt directly

1. In-memory library session as the authority.
   - In AOS, durable events + reducer state are authoritative.
2. Provider/CLI-specific runtime assumptions (for example process-group kill behavior) at core schema level.
   - Those belong in adapter/tool contracts, not base session schemas.
3. A single generic `SessionEvent` map payload model.
   - In AOS we need strongly typed, versioned schemas for replay safety.
4. Implicit cancellation semantics.
   - AOS requires explicit event ordering and epoch fences for deterministic stale-result handling.

### Practical rule

When the loop spec and AOS constraints differ, choose AOS invariants:
- deterministic replay,
- reducer-owned state transitions,
- plan-only orchestration of privileged effects,
- typed/versioned event contracts.

## Non-Goals

- Provider profile resolution logic (handled in P2.2).
- Tool output truncation/bounding policy (handled in P2.3).
- Failure taxonomy ownership and retry strategy (handled in P2.5).
- Streaming/event transport details.

## Deliverables

1. New AIR schema files for session lifecycle/control contracts.
2. `aos-agent-sdk` crate with:
   - core IDs and state/event types,
   - lifecycle transition helpers,
   - command-queue semantics (`steer`, `follow_up`),
   - active batch settle helpers,
   - lease heartbeat/expiry helpers.
3. Template keyed reducer and routing conventions:
   - key by `session_id`,
   - route `SessionEvent` to `SessionReducer`.
4. Cross-stage contract notes for P2.2/P2.3/P2.5 so later stages extend but do not redefine base session semantics.

## Specs Alignment

- `spec/03-air.md`: event-triggered plans and strict schema validation.
- `spec/04-reducers.md`: reducer owns state transitions and business logic.
- `spec/02-architecture.md`: journal-backed determinism and receipts.

## Exit Criteria

1. Deterministic no-tool run works end-to-end with lifecycle transitions.
2. `steer` is observed at step boundary before next LLM step.
3. `follow_up` is queued and consumed only after current run reaches `Idle`/`WaitingInput`.
4. Parallel tool fan-out/fan-in blocks next LLM step until active batch settles deterministically.
5. `cancel` transitions to `Cancelling` and ultimately `Cancelled`; stale late results are recorded and marked `IgnoredStale`.
6. Lease heartbeat renewal and lease-expiry cancellation path are deterministic from journaled command payloads.
7. Replay test proves byte-identical final state for equivalent journal.
