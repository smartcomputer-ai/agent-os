# P2.1: Session Contracts and Core `aos.agent/*` Schemas

**Stage**: P2.1  
**Status**: Proposed  
**Depends on**: P1 complete

## Purpose

Establish the base session lifecycle and host-control contract so every agent app shares the same run semantics.

This stage resolves the primary gap from concern #1 (host-control underspecified) and lays schema foundations used by all later stages.

## Why Multiple IDs

We need four identity levels because they solve different problems:

- `session_id`: stable identity for long-lived conversation/state.
- `run_id`: identity for one execution attempt inside a session.
- `turn_id`: identity for one LLM round within a run.
- `step_id`: identity for one fine-grained action boundary inside a turn.

If we collapse these into one ID, we lose deterministic cancellation fences, traceability, and clean operator controls.

### Function of each ID

1. `session_id`
   - Reducer cell key (`key_field` target).
   - Long-lived memory boundary (settings/history/cache).
   - Used by UI/API as the durable handle.
2. `run_id`
   - Distinguishes separate executions in the same session.
   - Terminal state boundary (`Completed`/`Failed`/`Cancelled`) is per run.
   - Needed so late receipts from old runs can be ignored.
3. `turn_id`
   - Groups one LLM request/response cycle.
   - Correlates tool calls/results to the exact model response that produced them.
4. `step_id`
   - Total ordering inside a turn for host-control observation and event replay analysis.
   - Causation anchor for effect intents/receipts and diagnostics.

## Identity Model (hierarchical)

Instead of opaque unrelated strings, IDs are hierarchical so parent/child relationships are explicit:

- `RunId = { session_id, run_seq }`
- `TurnId = { run_id, turn_seq }`
- `StepId = { turn_id, step_seq }`

This allows deterministic incrementing in reducer state while limiting UUID generation to the session boundary.

## Scope

1. Define core SDK schemas under `aos.agent/*`:
   - `aos.agent/SessionId@1`
   - `aos.agent/RunId@1`
   - `aos.agent/TurnId@1`
   - `aos.agent/StepId@1`
   - `aos.agent/ReasoningEffort@1`
   - `aos.agent/SessionConfig@1`
   - `aos.agent/RunConfig@1`
   - `aos.agent/SessionLifecycle@1`
   - `aos.agent/HostCommand@1`
   - `aos.agent/SessionEventKind@1`
   - `aos.agent/SessionState@1`
   - `aos.agent/SessionEvent@1`
2. Define lifecycle states and transitions:
   - `Idle`, `Running`, `WaitingInput`, `Paused`, `Cancelling`, `Completed`, `Failed`, `Cancelled`
3. Define control observation semantics:
   - `steer`, `follow_up`, `pause`, `resume`, `cancel`
4. Define epoch fences to ignore stale completions:
   - `session_epoch`
   - `step_epoch`
5. Add crate scaffolding:
   - `crates/aos-agent-sdk` with shared types and reducer helper traits.

## Proposed Schema Shapes (AIR-style)

Below is the intended shape. Final field names can be adjusted, but the semantics should stay.

### Identity Schemas

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionId@1",
  "type": { "uuid": {} }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunId@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "run_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/TurnId@1",
  "type": {
    "record": {
      "run_id": { "ref": "aos.agent/RunId@1" },
      "turn_seq": { "nat": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/StepId@1",
  "type": {
    "record": {
      "turn_id": { "ref": "aos.agent/TurnId@1" },
      "step_seq": { "nat": {} }
    }
  }
}
```

### Lifecycle and Commands

```json
{
  "$kind": "defschema",
  "name": "aos.agent/ReasoningEffort@1",
  "type": {
    "variant": {
      "Low": { "unit": {} },
      "Medium": { "unit": {} },
      "High": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionConfig@1",
  "type": {
    "record": {
      "provider_profile_id": { "option": { "text": {} } },
      "provider": { "option": { "text": {} } },
      "model": { "option": { "text": {} } },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

`SessionConfig@1` and `RunConfig@1` intentionally share the same field shape.
They remain separate schema names because they have different lifecycle meaning:
- `SessionConfig@1`: mutable defaults for future runs.
- `RunConfig@1`: resolved immutable snapshot for one active run.

```json
{
  "$kind": "defschema",
  "name": "aos.agent/RunConfig@1",
  "type": {
    "record": {
      "provider_profile_id": { "option": { "text": {} } },
      "provider": { "text": {} },
      "model": { "text": {} },
      "reasoning_effort": { "option": { "ref": "aos.agent/ReasoningEffort@1" } },
      "max_tokens": { "option": { "nat": {} } }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionLifecycle@1",
  "type": {
    "variant": {
      "Idle": { "unit": {} },
      "Running": { "unit": {} },
      "WaitingInput": { "unit": {} },
      "Paused": { "unit": {} },
      "Cancelling": { "unit": {} },
      "Completed": { "unit": {} },
      "Failed": { "unit": {} },
      "Cancelled": { "unit": {} }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/HostCommand@1",
  "type": {
    "record": {
      "command_id": { "uuid": {} },
      "target_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "expected_session_epoch": { "option": { "nat": {} } },
      "issued_at": { "time": {} },
      "command": {
        "variant": {
          "Steer": { "record": { "text": { "text": {} } } },
          "FollowUp": { "record": { "text": { "text": {} } } },
          "Pause": { "unit": {} },
          "Resume": { "unit": {} },
          "Cancel": { "record": { "reason": { "option": { "text": {} } } } }
        }
      }
    }
  }
}
```

`command_id` exists for idempotency and audit (host retries should not double-apply control).
`target_run_id` scopes the command to a specific run when provided.
`expected_session_epoch` is an optional optimistic-concurrency fence to reject stale control actions.

### Host command targeting semantics

- If `target_run_id` is present: apply only if it matches the active run, otherwise reject as stale/invalid target.
- If `target_run_id` is absent: apply to current active run (best-effort convenience path).
- If `expected_session_epoch` is present: apply only when it matches current session epoch.

### Session State

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionState@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "lifecycle": { "ref": "aos.agent/SessionLifecycle@1" },
      "session_epoch": { "nat": {} },
      "step_epoch": { "nat": {} },
      "next_run_seq": { "nat": {} },
      "next_turn_seq": { "nat": {} },
      "next_step_seq": { "nat": {} },
      "session_config": { "ref": "aos.agent/SessionConfig@1" },
      "active_run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "active_run_config": { "option": { "ref": "aos.agent/RunConfig@1" } },
      "active_turn_id": { "option": { "ref": "aos.agent/TurnId@1" } },
      "active_step_id": { "option": { "ref": "aos.agent/StepId@1" } },
      "pending_steer": { "list": { "text": {} } },
      "pending_follow_up": { "list": { "text": {} } },
      "created_at": { "time": {} },
      "updated_at": { "time": {} }
    }
  }
}
```

### Event Envelope

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionEvent@1",
  "type": {
    "record": {
      "session_id": { "ref": "aos.agent/SessionId@1" },
      "run_id": { "option": { "ref": "aos.agent/RunId@1" } },
      "turn_id": { "option": { "ref": "aos.agent/TurnId@1" } },
      "step_id": { "option": { "ref": "aos.agent/StepId@1" } },
      "session_epoch": { "nat": {} },
      "step_epoch": { "nat": {} },
      "event": { "ref": "aos.agent/SessionEventKind@1" }
    }
  }
}
```

```json
{
  "$kind": "defschema",
  "name": "aos.agent/SessionEventKind@1",
  "type": {
    "variant": {
      "RunRequested": {
        "record": {
          "input_ref": { "hash": {} },
          "run_overrides": { "option": { "ref": "aos.agent/SessionConfig@1" } }
        }
      },
      "RunStarted": { "unit": {} },
      "HostCommandReceived": { "ref": "aos.agent/HostCommand@1" },
      "HostCommandApplied": { "record": { "command_id": { "uuid": {} } } },
      "LifecycleChanged": { "ref": "aos.agent/SessionLifecycle@1" },
      "RunCompleted": { "unit": {} },
      "RunFailed": { "record": { "code": { "text": {} }, "detail": { "text": {} } } },
      "RunCancelled": { "record": { "reason": { "option": { "text": {} } } } }
    }
  }
}
```

`SessionEvent` is an envelope so correlation fields are always present and uniform for tooling.

## Model Mutability Rule

Model/provider can change within a session, but only at run boundaries:

1. Session stores mutable defaults in `session_config`.
2. `RunRequested.run_overrides` may override those defaults for the next run.
3. On `RunStarted`, reducer resolves and snapshots `active_run_config`.
4. `active_run_config.provider` and `active_run_config.model` are immutable until run terminal state.
5. Next run may use different resolved model/provider.

## Runtime Use of IDs (example timeline)

Given `session_id = "550e8400-e29b-41d4-a716-446655440000"`:

1. First input starts `run_id = {session_id:"550e8400-e29b-41d4-a716-446655440000", run_seq:1}`.
2. First model round starts `turn_id = {run_id, turn_seq:1}`.
3. Steps progress:
   - `step_id(..., step_seq:1)` for `LlmStepRequested`
   - `step_id(..., step_seq:2)` for tool fan-out request
   - `step_id(..., step_seq:3)` for result ingestion
4. Host issues cancel:
   - reducer sets lifecycle `Cancelling`
   - increments `session_epoch`
5. Late receipt from old step arrives with stale epoch:
   - ignored deterministically.

This is why IDs and epochs are both needed:
- IDs give lineage,
- epochs give safe invalidation boundaries.

## Relationship to `tmp-llm-lib-code/02-coding-agent-loop-spec.md`

That document is useful inspiration, but it is not a source of truth for AOS contracts.

### Adopt (with adaptation)

1. Explicit session lifecycle states.
2. Host control queues (`steer`, `follow_up`) and next-boundary observation semantics.
3. Limit-driven loop control (`max_turns`, round limits) as first-class config.
4. Strong event-driven mindset for host integrations.

### Do not adopt directly

1. In-memory library session as the authority.
   - In AOS, durable events + reducer state are authoritative.
2. Provider/CLI-specific runtime assumptions (for example process-group kill behavior) at core schema level.
   - Those belong in adapter/tool contracts, not base session schemas.
3. A single generic `SessionEvent` map payload model.
   - In AOS we need strongly typed, versioned schemas for replay safety.
4. Implicit cancellation semantics.
   - AOS requires explicit event ordering and epoch fences for deterministic stale-result handling.

### Practical rule

When the loop spec and AOS constraints differ, choose AOS invariants:
- deterministic replay,
- reducer-owned state transitions,
- plan-only orchestration of privileged effects,
- typed/versioned event contracts.

## Non-Goals

- Provider-specific profile logic.
- Tool bounding/truncation.
- Streaming/event transport details.

## Deliverables

1. New AIR schema files for session lifecycle/control contracts.
2. `aos-agent-sdk` crate with:
   - core IDs and state/event types,
   - lifecycle transition helpers,
   - command-queue semantics (`steer`, `follow_up`).
3. Template keyed reducer and routing conventions:
   - key by `session_id`,
   - route `SessionEvent` to `SessionReducer`.

## Specs Alignment

- `spec/03-air.md`: event-triggered plans and strict schema validation.
- `spec/04-reducers.md`: reducer owns state transitions and business logic.
- `spec/02-architecture.md`: journal-backed determinism and receipts.

## Exit Criteria

1. Deterministic no-tool run works end-to-end with lifecycle transitions.
2. `steer` is observed at step boundary before next LLM step.
3. `follow_up` is queued and consumed only after current run reaches `Idle`/`WaitingInput`.
4. `cancel` transitions to `Cancelling` and ultimately `Cancelled`; stale late results are ignored by epoch fence.
5. Replay test proves byte-identical final state for equivalent journal.
