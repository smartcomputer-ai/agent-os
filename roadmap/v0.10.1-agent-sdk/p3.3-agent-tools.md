# P3.3: Agent Tools Contract (Descriptors, Binding, Authority)

**Priority**: P3  
**Effort**: Medium  
**Risk if deferred**: High (tool visibility and tool authority remain conflated)  
**Status**: Proposed (new split on 2026-02-22)

## Goal

Define where tools live and how they execute safely:

1. model-visible tool descriptors,
2. runtime binding from `tool_name` to intents/plans/effects,
3. capability/policy enforcement boundaries.

This document is tool-only. Prompt concerns remain in `p3.2-agent-prompts.md`.

## Core Answer: Where Should Tools Be Defined?

Split tool definition into two layers:

1. **Descriptor layer (content)**: JSON schema/name/description shown to LLM.
2. **Binding layer (authority)**: reducer + AIR mapping from `tool_name` to typed intents and plan/effect execution.

Recommendation:

1. descriptor layer may live in workspace or direct config CAS refs,
2. binding layer must live in app/SDK control plane, never in workspace files.

## Problem

Current discussion mixed catalogs, packs, and runtime execution. That creates ambiguity:

1. if tool JSON changes in workspace, does authority change?
2. who owns mapping from `tool_name` to actual effects?
3. can simple apps avoid extra catalog indirection?

Tools need a clear convention-first data shape plus hard authority boundaries.

## Decision Summary

1. Workspace tool catalogs are optional, not required.
2. Convention-first file layout is enough for workspace mode:
   - `tools/catalogs/<catalog>.json`
3. Descriptor indirection via `tools/descriptors/*` is optional metadata, not mandatory in v0.10.
4. Execution authority is never loaded from workspace content.
5. A tool call executes only when:
   - descriptor is visible for the run,
   - reducer binding exists for the tool name,
   - triggered plans/effects pass caps/policy.
6. SDK should export composable-core tool plans:
   - descriptor sync plans,
   - optional effect-bridge plans for stable built-in tool effects.

## SDK Plan Exports (Tools)

Target reusable plans in `crates/aos-agent-sdk/air/plans/`:

1. `aos.agent/core_tool_catalog_sync_from_workspace@1`
   - input: tool-catalog-specific workspace sync request contract,
   - output: tool catalog snapshot-ready or unchanged result contract.
2. Optional effect-bridge family (`core_tool_effect_*`) for stable built-in effects where shared orchestration is useful.

Composition:

1. prompt + tool workspace sync can be composed by a parent plan (for example `core_workspace_sync@2`) using `spawn_plan` + `await_plans_all`.
2. app worlds import only the plans they need.

## Descriptor Sources

### A) Workspace Catalog (existing path)

Tool catalog comes from active workspace snapshot:

1. sync/apply resolves `tool_catalog_ref`,
2. helper injects it as `tool_refs` when no explicit tool refs are set.

### B) Direct Tool Refs (no workspace)

Add direct tool refs to config (next contract rev):

1. session defaults:
   - `default_tool_refs: option<list<hash>>`
2. run overrides:
   - `tool_refs: option<list<hash>>`

These refs point to LLM-facing tool JSON blobs in CAS.

## Descriptor JSON Shape

Keep input permissive and convention-based:

1. object with `tools: [...]` (recommended),
2. array of tool defs,
3. single tool object.

Optional `tool_choice` in descriptor blob is allowed.

No mandatory pack/catalog meta schema is required for execution.

## Binding/Authority Model

Binding is owned by reducer + plan contracts:

1. reducer parses normalized tool calls from LLM output,
2. reducer maps `tool_name` -> typed intent params,
3. plans execute allowed effects behind caps/policy,
4. reducer ingests tool result events and advances state.

Workspace files can influence model visibility, not runtime authority.

Reducer binding contract should be explicit:

1. `tool_name` -> intent schema (typed payload),
2. intent schema -> triggered plan(s),
3. plan(s) -> allowed effect set + cap slots + policy constraints.

## Precedence for Tool Visibility

Per step:

1. explicit step tool refs (`step.tool_refs`) win,
2. else run config tool refs (direct mode) if set,
3. else active workspace `tool_catalog_ref` if set,
4. else no tools for that step.

## Required Safety Checks

At tool-call handling time:

1. reject calls for tool names not visible in active descriptor set,
2. reject calls for tool names without binding,
3. validate arguments against binding schema/decoder,
4. emit structured rejection events for observability.

At sync/apply time (workspace mode):

1. validate tool catalog JSON shape (already present),
2. add optional check that all visible tool names have bindings (new work).

## Convention vs Catalog Indirection

For v0.10:

1. allow direct `tools/catalogs/<name>.json` as the primary convention,
2. keep `agent.workspace.json` catalog map as optional convenience,
3. do not carry ad hoc workspace directory scan paths in the new contract.

This gives low friction while keeping deterministic lookup.

## Implementation Focus

1. Add direct `tool_refs` config path for no-workspace agents.
2. Export tool-catalog sync core plan in SDK AIR.
3. Introduce deterministic binding coverage checks in SDK/Demiurge reducers.
4. Add optional SDK effect-bridge plans for stable built-in tool effects.
5. Keep convention-first workspace catalog loading.

## Testing

Deterministic coverage:

1. no-workspace run with direct `tool_refs`,
2. workspace run with `tool_catalog_ref`,
3. precedence across explicit step refs/direct refs/workspace refs,
4. unbound tool call rejection without state corruption,
5. policy/cap denial propagation through tool plans.
6. imported SDK tool sync/effect-bridge plans execute without app-local wrapper duplication.

## Definition of Done

1. Tool contract is documented separately from prompts.
2. SDK exports a tool-catalog-specific reusable sync plan.
3. Descriptor source can be workspace or direct config refs.
4. Binding/authority stays outside workspace and is enforced.
5. At least one smoke fixture demonstrates direct tool refs with no workspace dependency.

## Open Questions

1. Do we keep `tool_choice` in descriptor blobs only, or also expose a first-class run field?
2. Should binding coverage validation be hard-fail on sync/apply or a warning first?
3. Do we want a standardized `aos.agent/ToolRejected@1` event in v0.10?
