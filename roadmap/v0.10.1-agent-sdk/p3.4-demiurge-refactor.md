# P3: Refactor Demiurge onto Agent SDK

**Priority**: P3  
**Effort**: Medium  
**Risk if deferred**: Medium (Demiurge remains a special-case toy path)  
**Status**: In Progress (2026-02-22)

## Goal

My goals:
- single shot refactor: move to sdk in one go
- considered used of tools: expand available effects first, add tool call to effect mapping support in sdk, requires thinking about what tools to support.
- first version of a solution how to use external schema definitions (from sdk), beyond sys/* (do not repeat schemas)

---

Refactor `apps/demiurge` to consume `aos-agent-sdk` primitives so Demiurge becomes:
- a real reference implementation for AOS-native agents,
- a proving ground for coding-agent and world-operator flows,
- less bespoke reducer/plan code over time.

This document is intentionally lighter than P1/P2 because SDK contracts will evolve during implementation.

## Current State (Why Refactor)

Demiurge today is a useful prototype:
- chat request/response loop,
- tool call parsing/dispatch,
- workspace/introspect tools,
- debug trace support.

But it is still app-specific and embeds patterns the SDK should own.

## Refactor Direction

1. Move Demiurge to SDK primitives in one refactor pass.
2. Treat Demiurge as the first major integration test for the new SDK.
3. Adopt `aos.agent/*` as the core namespace for runtime-facing contracts.

## Non-Goals (P3)

- Not a full product redesign of shell UX.
- Not the final coding-agent implementation.
- Not final multi-world universe orchestration.

## Implementation Slices

### Slice 3.1: Event/schema alignment
- Map Demiurge chat/tool events to `aos.agent/*` run/turn/action concepts.
- Remove obsolete schema/event paths in the same change set.

### Slice 3.2: Reducer refactor
- Replace bespoke loop fields/state transitions with SDK reducer helpers.
- Standardize pending/waiting/error states to SDK conventions.
- Preserve deterministic behavior and request correlation guarantees.

### Slice 3.3: Plan/tool refactor
- Replace custom tool orchestration patterns with imported SDK composable-core plans.
- Ensure LLM request materialization is direct from immutable run config:
  - `RunRequested` chooses session defaults or run override,
  - `RunStarted` snapshots immutable `{provider, model, ...}`,
  - steps emit `llm.generate` from run config + deterministic step context.
- Replace fixture-local wrapper-only routing where possible with trigger projection (`when` + `input_expr`) directly into imported core plans.
- Adopt split workspace sync contracts/plans:
  - `aos.agent/core_prompt_sync_from_workspace@1`,
  - `aos.agent/core_tool_catalog_sync_from_workspace@1`,
  - composed parent `aos.agent/core_workspace_sync@1`.
- Keep current introspect/workspace tools functional.
- Add at least one SDK effect-bridge tool execution path to validate extensibility.
- Adopt new effect/tool families from P4 incrementally (starting with low-risk workspace-native operations).

### Slice 3.4: Operational hardening
- Align debug surfaces with SDK terminology (run/turn/action lineage).
- Expand e2e tests to cover:
  - tool errors,
  - cap/policy denials,
  - multi-step tool continuation,
  - parent/child session orchestration events.

### Slice 3.5: Advanced toolset enablement
- Add coding-agent-grade tools as Demiurge capabilities once P4 contracts land:
  - patch-style workspace edits,
  - shell execution,
  - compiler/build flows.
- Keep each capability behind explicit caps/policy and validate traceability end-to-end.

## Wiring Invariants from Current Demiurge

These invariants must be preserved during refactor to avoid regressions:

1. Tool execution stays plan-only under caps/policy.
2. Reducer remains the tool-call interpreter and state owner.
3. CAS refs remain the interface between LLM output, tool results, and state.
4. Tool registry refresh remains explicit and version-aware.
5. Reducer micro-effects remain limited to blob bridging behavior, not tool orchestration.
6. Provider/model selection is explicit in session/run config and frozen per run.
7. Demiurge consumes core-owned `sys/*` LLM contracts and must not introduce app- or SDK-local `sys/*` schema forks.

## Testing

- Preserve existing Demiurge e2e coverage as baseline.
- Add replay parity tests for migrated flows.
- Add SDK conformance tests that run against Demiurge as a fixture app.
- Keep `crates/aos-smoke` as the single e2e runner for SDK-level scenarios; avoid adding a Demiurge-specific parallel runner.

## Progress Notes (2026-02-22)

Completed groundwork in SDK + smoke fixture:

1. Prompt/tool split subplans exported:
   - `core_prompt_sync_from_workspace@1`
   - `core_tool_catalog_sync_from_workspace@1`
2. Composed parent exported:
   - `core_workspace_sync@1`
3. Live SDK smoke fixture (`22-agent-live`) wrapper/manifests/policies now target
   composed `core_workspace_sync@1` path.

Remaining in this roadmap item:

1. Demiurge app migration itself still pending across slices 3.1-3.5.

## Definition of Done

- Demiurge core loop runs on SDK primitives rather than bespoke chat-only structures.
- Existing core features (chat + tools + debug trace) remain functional.
- At least one new agent behavior can be added in Demiurge with SDK extension points and minimal bespoke code.
- Obsolete Demiurge-only schema/event pathways are removed.
- App-local duplicated core sync wrappers are removed where trigger projection + imported core plans can replace them.
- Runtime behavior matches current working tool path semantics while moving naming/contracts to `aos.agent/*`.

## Open Questions

- How aggressively should we rename public Demiurge schemas during v0.10?
- Do we keep one monolithic Demiurge reducer initially, or split by SDK domain boundaries?
- Which coding-agent features should land in Demiurge vs a separate app once SDK is ready?
